<!DOCTYPE html>
<html lang="zh-HK">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ğŸ¶ äººå¯µé…å° v3.5 (Lite)</title>
    <!-- CSS -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css">
    <!-- AI Libraries (åŠ  defer ç¢ºä¿å””block render) -->
    <script defer src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@latest"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/@tensorflow-models/mobilenet@latest"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/face-api.js@0.22.2/dist/face-api.min.js"></script>
    <script defer src="https://cdnjs.cloudflare.com/ajax/libs/color-thief/2.3.0/color-thief.umd.js"></script>

    <style>
        body { padding: 20px; text-align: center; max-width: 800px; margin: 0 auto; background-color: #fdfbf7; font-family: 'Segoe UI', sans-serif; }
        
        .preview-box { 
            width: 180px; height: 180px; 
            border: 3px solid #eee; margin: 30px auto; 
            position: relative; cursor: pointer;
            background: #fff; border-radius: 50%; 
            box-shadow: 0 4px 10px rgba(0,0,0,0.1);
        }

        .img-container {
            width: 100%; height: 100%; border-radius: 50%; overflow: hidden;
            display: flex; align-items: center; justify-content: center;
        }
        img { width: 100%; height: 100%; object-fit: cover; }
        
        .bubble {
            background: #fff; color: #333; padding: 10px 15px; border-radius: 15px;
            font-size: 0.8rem; font-weight: bold; line-height: 1.4;
            position: absolute; top: -50px; right: -70px; 
            width: 150px; z-index: 100; display: none; 
            box-shadow: 3px 3px 10px rgba(0,0,0,0.15); border: 2px solid #333;
            pointer-events: none;
        }
        .bubble::after { content: ''; position: absolute; bottom: -10px; left: 20px; border-width: 12px 10px 0; border-style: solid; border-color: #333 transparent; display: block; width: 0; }
        .bubble::before { content: ''; position: absolute; bottom: -6px; left: 23px; border-width: 9px 7px 0; border-style: solid; border-color: #fff transparent; display: block; width: 0; z-index: 1; }

        .grid { display: grid; grid-template-columns: 1fr 1fr; gap: 40px; margin-bottom: 20px; }
        #result-area { display: none; margin-top: 30px; padding: 40px; background: #fff; border-radius: 20px; box-shadow: 0 10px 25px rgba(0,0,0,0.1); }
        .score-circle { width: 150px; height: 150px; background: #ffb703; color: #fff; border-radius: 50%; display: flex; flex-direction: column; align-items: center; justify-content: center; margin: 0 auto 20px auto; }
        .score-number { font-size: 3.5rem; font-weight: 800; line-height: 1; }
        .tag { background: #eee; padding: 5px 15px; border-radius: 20px; font-size: 0.9rem; font-weight: bold; color: #555; margin: 5px; display:inline-block;}
        .tag.highlight { background: #d4edda; color: #155724; border: 1px solid #c3e6cb; }
        
        #loading-overlay { position: fixed; top:0; left:0; width:100%; height:100%; background:rgba(255,255,255,0.95); z-index:999; display:flex; justify-content:center; align-items:center; flex-direction:column; transition: opacity 0.5s; }
    </style>
</head>
<body>

    <div id="loading-overlay">
        <h2>ğŸš€ å•Ÿå‹• AI å¼•æ“ä¸­...</h2>
        <p id="loading-text">æ­£åœ¨å–šé†’ MobileNet...</p>
        <small style="color:#999; margin-top:10px;">(é¦–æ¬¡è¼‰å…¥å¯èƒ½éœ€è¦ 10-20 ç§’)</small>
    </div>

    <main class="container">
        <h1>ğŸ¶ äººå¯µé…å° v3.5</h1>
        <p>å–®äººæ¨¡å¼ + ç¨ç…§è­˜åˆ¥ (Lite)</p>

        <div class="grid">
            <div>
                <h3>1. ä¸»äººç›¸ ğŸ‘±</h3>
                <div class="preview-box" id="box1" onclick="triggerUpload('upload1')">
                    <div id="bubble1" class="bubble"></div>
                    <div class="img-container">
                        <span style="color:#ccc; font-size:2rem;">+</span>
                        <img id="img1" style="display:none;" crossorigin="anonymous">
                    </div>
                </div>
                <input type="file" id="upload1" accept="image/*" onchange="checkHuman(event)" style="display:none;">
            </div>
            <div>
                <h3>2. ç‹—ç‹—ç›¸ ğŸ¶</h3>
                <div class="preview-box" id="box2" onclick="triggerUpload('upload2')">
                     <div id="bubble2" class="bubble"></div>
                     <div class="img-container">
                        <span style="color:#ccc; font-size:2rem;">+</span>
                        <img id="img2" style="display:none;" crossorigin="anonymous">
                     </div>
                </div>
                <input type="file" id="upload2" accept="image/*" onchange="checkDog(event)" style="display:none;">
            </div>
        </div>

        <button id="analyzeBtn" onclick="analyzeSimilarity()" disabled style="width: 100%; font-size: 1.2rem; padding: 20px;">ğŸ¤– ç«‹å³åˆ†æ</button>
        
        <div id="result-area">
            <div class="score-circle">
                <span class="score-number" id="score">0</span>
                <span>% ç›¸ä¼¼</span>
            </div>
            <h3 id="comment">...</h3>
            <div id="tags"></div>
            <br>
            <button onclick="window.location.reload()" class="secondary outline">ğŸ”„ å†ç©ä¸€æ¬¡</button>
        </div>
    </main>

    <script>
        let mobilenetModel;
        let isFaceApiReady = false;
        const colorThief = new ColorThief();
        const btn = document.getElementById('analyzeBtn');
        let humanStatus = { isHard: false };
        let dogStatus = { isHard: false };

        const DOG_KEYWORDS = [
            'dog', 'terrier', 'retriever', 'spaniel', 'hound', 'corgi', 'poodle', 'shepherd', 'husky', 'beagle', 'bulldog', 'dalmatian', 'pug', 'collie', 'malamute', 'schnauzer', 'chihuahua', 'shiba', 'akita', 'pomeranian', 'boxer', 'rottweiler', 'doberman', 'pinscher', 'dane', 'mastiff', 'bernese', 'newfoundland', 'samoyed', 'spitz', 'whippet', 'greyhound', 'vizsla', 'weimaraner', 'pointer', 'setter', 'labrador', 'maltese', 'papillon', 'pekinese', 'shih-tzu', 'bichon', 'frise',
            'wolf', 'fox', 'coyote', 'teddy', 'toy', 'wool', 'wig', 'bear'
        ];

        // 1. é †åºè¼‰å…¥ (Waterfall Loading)
        window.addEventListener('load', async () => {
            try {
                // Step 1: Load MobileNet First (è¼ƒå¿«)
                mobilenetModel = await mobilenet.load();
                console.log("MobileNet Loaded");
                
                // Hide Overlay Early
                document.getElementById('loading-overlay').style.opacity = '0';
                setTimeout(() => document.getElementById('loading-overlay').style.display = 'none', 500);

                // Step 2: Load FaceAPI in background
                document.getElementById('loading-text').innerText = "æ­£åœ¨è¼‰å…¥ Face-API...";
                await faceapi.nets.tinyFaceDetector.loadFromUri('https://justadudewhohacks.github.io/face-api.js/models');
                await faceapi.nets.faceLandmark68Net.loadFromUri('https://justadudewhohacks.github.io/face-api.js/models');
                isFaceApiReady = true;
                console.log("FaceAPI Loaded");

            } catch (e) {
                console.error(e);
                alert("AI è¼‰å…¥å‡ºç¾å•é¡Œï¼Œè«‹æª¢æŸ¥ç¶²çµ¡æˆ–é‡æ–°æ•´ç†ã€‚");
                document.getElementById('loading-overlay').style.display = 'none';
            }
        });

        function triggerUpload(id) {
            document.getElementById(id).click();
        }

        // 2. æª¢æŸ¥äººé¡ç›¸ (åŠ å·¦ Safety Check)
        async function checkHuman(event) {
            await loadFile(event, 'img1', 'box1', 'bubble1');
            const img = document.getElementById('img1');
            const bubble = document.getElementById('bubble1');
            humanStatus.isHard = false;
            bubble.style.display = 'none';
            btn.disabled = true;

            setTimeout(async () => {
                // Safety Check: å¦‚æœ AI æœª Ready
                if (!mobilenetModel || !isFaceApiReady) {
                    showBubble(bubble, "â³ AI ä»²ç†±ç·Šèº«ï¼Œè«‹ç­‰ 5 ç§’å†è©¦...", true, true);
                    return;
                }

                // Check 1: Animal Check
                const predictions = await mobilenetModel.classify(img);
                const isAnimal = predictions.some(p => {
                    const k = p.className.toLowerCase();
                    return DOG_KEYWORDS.some(dk => k.includes(dk)) || k.includes('cat') || k.includes('bird');
                });
                if (isAnimal) {
                    showBubble(bubble, "ğŸ¶ å–‚å–‚ï¼å‘¢é‚Šä¿‚æ”¾ä¸»äººç›¸æ¶ï¼", true, true);
                    return;
                }

                // Check 2: Multi-face Check
                const allFaces = await faceapi.detectAllFaces(img, new faceapi.TinyFaceDetectorOptions()).withFaceLandmarks();
                
                if (allFaces.length === 0) {
                    showBubble(bubble, "ğŸ¤” æµå””åˆ°äººæ¨£å–ï¼Ÿä½ ä¿‚å’ªéš±å½¢ä¿ ï¼Ÿ", true, true);
                    return;
                }
                
                if (allFaces.length > 1) {
                    showBubble(bubble, "ğŸ‘¥ å¤ªå¤šäººå•¦ï¼AI æƒ³ä¸€å°ä¸€å°ˆæ³¨ç‡çœŸå•²ï¼", true, true);
                    return;
                }

                const detection = allFaces[0];
                const landmarks = detection.landmarks;
                const leftEye = landmarks.getLeftEye();
                const rightEye = landmarks.getRightEye();
                const eyeDist = Math.abs(leftEye[0].x - rightEye[3].x);
                const faceWidth = detection.detection.box.width;
                const brightness = getBrightness(img);

                if (brightness < 50) {
                    showBubble(bubble, "ğŸ’¡ é–‹ç›ç‡ˆå¯ä»¥å—ï¼Ÿä½ å—°é‚Šé›»è²»å¥½è²´ï¼Ÿ", true, false);
                } 
                else if (eyeDist < faceWidth * 0.25) {
                    showBubble(bubble, "ğŸ‘€ å´é¢ä¿‚éšï¼Œä½†æ­£é¢ä»²éšï¼Œä¿¾å€‹æ­£é¢é»ç‡å“å•¦ï¼", true, false);
                } 
                else if (detection.detection.score < 0.7) {
                    showBubble(bubble, "ğŸ˜ æˆ´ä½é»‘è¶…å¤ªæœ‰å‹å–‡ï¼æ‰£ä½ 50åˆ†ï¼", true, false);
                }
                else {
                    showBubble(bubble, "âœ… é€™å¼µç›¸å¥½æ­£ï¼", false, false);
                }
                
                checkReady();
            }, 500);
        }

        async function checkDog(event) {
            await loadFile(event, 'img2', 'box2', 'bubble2');
            const img = document.getElementById('img2');
            const bubble = document.getElementById('bubble2');
            dogStatus.isHard = false;
            bubble.style.display = 'none';
            btn.disabled = true;

            setTimeout(async () => {
                if (!mobilenetModel) {
                     showBubble(bubble, "â³ AI è¼‰å…¥ä¸­...", true, true); return;
                }

                // Check 1: Human in Dog Photo?
                if (isFaceApiReady) {
                    const humanFaces = await faceapi.detectAllFaces(img, new faceapi.TinyFaceDetectorOptions());
                    if (humanFaces.length > 0) {
                        showBubble(bubble, "ğŸ¶ ä¸»å­ç¨ç…§å¥½å•²å–ï¼å””å¥½æ¶é¡ï¼", true, true);
                        return;
                    }
                }

                // Check 2: Cat Check
                const predictions = await mobilenetModel.classify(img, 5); 
                const isCat = predictions.some(p => p.className.toLowerCase().includes('cat') || p.className.toLowerCase().includes('tabby'));
                if (isCat) {
                    showBubble(bubble, "ğŸ± å–µï¼Ÿå‘¢åº¦ä¿‚ç‹—ç‹—å°ˆå€å–ï¼(è²“è²“è«‹ç­‰ Phase 2)", true, true);
                    return;
                }

                let isDog = false;
                let detectedBreed = "";
                for (let p of predictions) {
                    const className = p.className.toLowerCase();
                    if (DOG_KEYWORDS.some(k => className.includes(k))) {
                        isDog = true; detectedBreed = p.className.split(',')[0]; break;
                    }
                }

                if (!isDog) {
                    showBubble(bubble, "ğŸ¶ å””å¤ªä¼¼ç‹—å–... ä¸éæˆ‘åœ°ç…§è©¦ä¸‹å•¦ï¼", true, false);
                    dogStatus.isHard = true; checkReady();
                } else {
                    showBubble(bubble, `âœ… æ”¶åˆ°ï¼ä¿‚ä¸€éš»å¯æ„›çš„ ${detectedBreed}`, false, false);
                    checkReady();
                }
            }, 500);
        }

        function showBubble(el, msg, isWarning, isError) {
            el.innerText = msg; el.style.display = 'block';
            if (isError) { el.style.border = '2px solid #d32f2f'; el.style.color = '#d32f2f'; }
            else if (isWarning) { el.style.border = '2px solid #fbc02d'; el.style.color = '#f57f17'; 
                if (el.id === 'bubble1') humanStatus.isHard = true; if (el.id === 'bubble2') dogStatus.isHard = true;
            } else { el.style.border = '2px solid #2e7d32'; el.style.color = '#2e7d32'; }
        }

        function loadFile(event, imgId, boxId, bubbleId) {
            return new Promise(resolve => {
                const output = document.getElementById(imgId);
                const container = document.querySelector(`#${boxId} .img-container`);
                const plusSign = container.querySelector('span');
                if (event.target.files && event.target.files[0]) {
                    output.src = URL.createObjectURL(event.target.files[0]);
                    output.onload = () => { URL.revokeObjectURL(output.src); resolve(); }
                    plusSign.style.display = 'none'; output.style.display = 'block';
                }
            });
        }

        function checkReady() {
            const bubble1 = document.getElementById('bubble1');
            const bubble2 = document.getElementById('bubble2');
            const isErr1 = bubble1.style.borderColor === 'rgb(211, 47, 47)';
            const isErr2 = bubble2.style.borderColor === 'rgb(211, 47, 47)'; 
            const img1Vis = document.getElementById('img1').style.display === 'block';
            const img2Vis = document.getElementById('img2').style.display === 'block';
            if (img1Vis && img2Vis && !isErr1 && !isErr2) btn.disabled = false;
        }
        
        function getBrightness(image) {
            let canvas = document.createElement('canvas'); canvas.width = image.width; canvas.height = image.height;
            let ctx = canvas.getContext('2d'); ctx.drawImage(image, 0, 0);
            let imageData = ctx.getImageData(0,0,canvas.width,canvas.height);
            let r,g,b,avg; let colorSum = 0;
            for(let x = 0, len = imageData.data.length; x < len; x+=4) {
                r = imageData.data[x]; g = imageData.data[x+1]; b = imageData.data[x+2];
                avg = Math.floor((r+g+b)/3); colorSum += avg;
            }
            return Math.floor(colorSum / (image.width*image.height));
        }

        async function analyzeSimilarity() {
            const img1 = document.getElementById('img1');
            const img2 = document.getElementById('img2');
            btn.setAttribute("aria-busy", "true");
            setTimeout(async () => {
                const activation1 = mobilenetModel.infer(img1, true);
                const activation2 = mobilenetModel.infer(img2, true);
                const rawDist = cosineSimilarity(activation1, activation2);
                let score = mapRange(rawDist, 0.35, 0.75, 100, 10);
                let bonusTags = [];
                if (humanStatus.isHard && dogStatus.isHard) { score += 5; bonusTags.push("ğŸ˜ å…©å€‹éƒ½å’å‹"); }
                else if (humanStatus.isHard || dogStatus.isHard) { score *= 0.9; bonusTags.push("ğŸ“‰ å—å…‰ç·š/è§’åº¦å½±éŸ¿"); }
                const c1 = colorThief.getColor(img1); const c2 = colorThief.getColor(img2);
                const colorDist = Math.sqrt(Math.pow(c1[0]-c2[0],2) + Math.pow(c1[1]-c2[1],2) + Math.pow(c1[2]-c2[2],2));
                if (colorDist < 60) { score += 5; bonusTags.push("ğŸ¨ è‰²ç³»å¥½è¥¯"); }
                score = Math.min(99, Math.max(10, Math.round(score)));
                showResult(score, bonusTags);
                btn.setAttribute("aria-busy", "false");
            }, 100);
        }

        function showResult(score, tags) {
            document.getElementById('result-area').style.display = 'block';
            document.getElementById('score').innerText = score;
            const comment = document.getElementById('comment');
            if(score > 90) comment.innerText = "ğŸ˜± å¤±æ•£å¤šå¹´æ—¢è¦ªäººï¼";
            else if(score > 75) comment.innerText = "â¤ï¸ é»˜å¥‘åè¶³ï¼Œå¤©ç”Ÿä¸€å°ï¼";
            else if(score > 60) comment.innerText = "ğŸ˜ å¹¾æœ‰çˆ¶å­/æ¯å¥³ç›¸ï¼";
            else comment.innerText = "ğŸ˜‚ é›–ç„¶å””ä¼¼ï¼Œä½†å‹åœ¨æœ‰æ„›ï¼";
            const tagContainer = document.getElementById('tags'); tagContainer.innerHTML = "";
            tags.forEach(t => tagContainer.innerHTML += `<span class="tag highlight">${t}</span>`);
        }

        function cosineSimilarity(t1, t2) {
            const v1 = t1.dataSync(); const v2 = t2.dataSync();
            let dotProduct = 0, normA = 0, normB = 0;
            for (let i = 0; i < v1.length; i++) { dotProduct += v1[i] * v2[i]; normA += v1[i] * v1[i]; normB += v2[i] * v2[i]; }
            return dotProduct / (Math.sqrt(normA) * Math.sqrt(normB));
        }
        function mapRange(value, low1, high1, low2, high2) {
            return low2 + (high2 - low2) * (value - low1) / (high1 - low1);
        }
    </script>
</body>
</html>
