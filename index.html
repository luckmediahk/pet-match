<!DOCTYPE html>
<html lang="zh-HK">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ğŸ¶ äººå¯µé…å° v3.3</title>
    <!-- CSS -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css">
    <!-- AI Libraries -->
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@latest"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/mobilenet@latest"></script>
    <script src="https://cdn.jsdelivr.net/npm/face-api.js@0.22.2/dist/face-api.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/color-thief/2.3.0/color-thief.umd.js"></script>

    <style>
        body { padding: 20px; text-align: center; max-width: 800px; margin: 0 auto; background-color: #fdfbf7; font-family: 'Segoe UI', sans-serif; }
        
        .preview-box { 
            width: 180px; height: 180px; 
            border: 3px solid #eee; margin: 30px auto; 
            position: relative; cursor: pointer;
            background: #fff; border-radius: 50%; 
            box-shadow: 0 4px 10px rgba(0,0,0,0.1);
        }

        .img-container {
            width: 100%; height: 100%; border-radius: 50%; overflow: hidden;
            display: flex; align-items: center; justify-content: center;
        }
        img { width: 100%; height: 100%; object-fit: cover; }
        
        /* æ¼«ç•«å¼ Bubble */
        .bubble {
            background: #fff; color: #333; padding: 10px 15px; border-radius: 15px;
            font-size: 0.8rem; font-weight: bold; line-height: 1.4;
            position: absolute; top: -50px; right: -70px; 
            width: 150px; z-index: 100; display: none; 
            box-shadow: 3px 3px 10px rgba(0,0,0,0.15); border: 2px solid #333;
            animation: popUp 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275); pointer-events: none;
        }
        .bubble::after { content: ''; position: absolute; bottom: -10px; left: 20px; border-width: 12px 10px 0; border-style: solid; border-color: #333 transparent; display: block; width: 0; }
        .bubble::before { content: ''; position: absolute; bottom: -6px; left: 23px; border-width: 9px 7px 0; border-style: solid; border-color: #fff transparent; display: block; width: 0; z-index: 1; }

        @keyframes popUp { from { transform: scale(0) rotate(-10deg); opacity: 0; } to { transform: scale(1) rotate(0deg); opacity: 1; } }

        .grid { display: grid; grid-template-columns: 1fr 1fr; gap: 40px; margin-bottom: 20px; }
        #result-area { display: none; margin-top: 30px; padding: 40px; background: #fff; border-radius: 20px; box-shadow: 0 10px 25px rgba(0,0,0,0.1); }
        .score-circle { width: 150px; height: 150px; background: #ffb703; color: #fff; border-radius: 50%; display: flex; flex-direction: column; align-items: center; justify-content: center; margin: 0 auto 20px auto; }
        .score-number { font-size: 3.5rem; font-weight: 800; line-height: 1; }
        .tag { background: #eee; padding: 5px 15px; border-radius: 20px; font-size: 0.9rem; font-weight: bold; color: #555; margin: 5px; display:inline-block;}
        .tag.highlight { background: #d4edda; color: #155724; border: 1px solid #c3e6cb; }
        #loading-overlay { position: fixed; top:0; left:0; width:100%; height:100%; background:rgba(255,255,255,0.95); z-index:999; display:flex; justify-content:center; align-items:center; flex-direction:column; }
    </style>
</head>
<body>

    <div id="loading-overlay">
        <h2>ğŸš€ å•Ÿå‹• AI å¼•æ“ä¸­...</h2>
        <p>æ­£åœ¨è¼‰å…¥äººè‡‰è­˜åˆ¥æ¨¡çµ„ (é¦–æ¬¡éœ€æ™‚ç´„ 10 ç§’)</p>
    </div>

    <main class="container">
        <h1>ğŸ¶ äººå¯µé…å° v3.3</h1>
        <p>æ™ºèƒ½åµæ¸¬ + åæ¬ºé¨™ç³»çµ±</p>

        <div class="grid">
            <!-- ä¸»äººç›¸ -->
            <div>
                <h3>1. ä¸»äººç›¸ ğŸ‘±</h3>
                <div class="preview-box" id="box1" onclick="document.getElementById('upload1').click()">
                    <div id="bubble1" class="bubble"></div>
                    <div class="img-container">
                        <span style="color:#ccc; font-size:2rem;">+</span>
                        <img id="img1" style="display:none;" crossorigin="anonymous">
                    </div>
                </div>
                <input type="file" id="upload1" accept="image/*" onchange="checkHuman(event)" style="display:none;">
            </div>
            <!-- ç‹—ç‹—ç›¸ -->
            <div>
                <h3>2. ç‹—ç‹—ç›¸ ğŸ¶</h3>
                <div class="preview-box" id="box2" onclick="document.getElementById('upload2').click()">
                     <div id="bubble2" class="bubble"></div>
                     <div class="img-container">
                        <span style="color:#ccc; font-size:2rem;">+</span>
                        <img id="img2" style="display:none;" crossorigin="anonymous">
                     </div>
                </div>
                <input type="file" id="upload2" accept="image/*" onchange="checkDog(event)" style="display:none;">
            </div>
        </div>

        <button id="analyzeBtn" onclick="analyzeSimilarity()" disabled style="width: 100%; font-size: 1.2rem; padding: 20px;">ğŸ¤– ç«‹å³åˆ†æ</button>
        
        <div id="result-area">
            <div class="score-circle">
                <span class="score-number" id="score">0</span>
                <span>% ç›¸ä¼¼</span>
            </div>
            <h3 id="comment">...</h3>
            <div id="tags"></div>
            <br>
            <button onclick="window.location.reload()" class="secondary outline">ğŸ”„ å†ç©ä¸€æ¬¡</button>
        </div>
    </main>

    <script>
        let mobilenetModel;
        const colorThief = new ColorThief();
        const btn = document.getElementById('analyzeBtn');
        let humanStatus = { isHard: false };
        let dogStatus = { isHard: false };

        const DOG_KEYWORDS = [
            'dog', 'terrier', 'retriever', 'spaniel', 'hound', 'corgi', 'poodle', 'shepherd', 'husky', 'beagle', 'bulldog', 'dalmatian', 'pug', 'collie', 'malamute', 'schnauzer', 'chihuahua', 'shiba', 'akita', 'pomeranian', 'boxer', 'rottweiler', 'doberman', 'pinscher', 'dane', 'mastiff', 'bernese', 'newfoundland', 'samoyed', 'spitz', 'whippet', 'greyhound', 'vizsla', 'weimaraner', 'pointer', 'setter', 'labrador', 'maltese', 'papillon', 'pekinese', 'shih-tzu', 'bichon', 'frise',
            'wolf', 'fox', 'coyote', 'teddy', 'toy', 'wool', 'wig', 'bear'
        ];

        async function initAI() {
            try {
                mobilenetModel = await mobilenet.load();
                await faceapi.nets.tinyFaceDetector.loadFromUri('https://justadudewhohacks.github.io/face-api.js/models');
                await faceapi.nets.faceLandmark68Net.loadFromUri('https://justadudewhohacks.github.io/face-api.js/models');
                document.getElementById('loading-overlay').style.display = 'none';
            } catch (e) { console.error(e); }
        }
        initAI();

        // 2. æª¢æŸ¥äººé¡ç›¸ (é›™é‡é©—è­‰: FaceAPI + MobileNet)
        async function checkHuman(event) {
            await loadFile(event, 'img1', 'box1', 'bubble1');
            const img = document.getElementById('img1');
            const bubble = document.getElementById('bubble1');
            humanStatus.isHard = false;
            bubble.style.display = 'none';
            btn.disabled = true;

            setTimeout(async () => {
                // Check 1: MobileNet ç‡ä¸‹ä¿‚å’ªå‹•ç‰©
                const predictions = await mobilenetModel.classify(img);
                const isAnimal = predictions.some(p => {
                    const k = p.className.toLowerCase();
                    return DOG_KEYWORDS.some(dk => k.includes(dk)) || k.includes('cat') || k.includes('bird');
                });

                if (isAnimal) {
                    showBubble(bubble, "ğŸ¶ å–‚å–‚ï¼å‘¢é‚Šä¿‚æ”¾ä¸»äººç›¸æ¶ï¼", true, true);
                    return; // Block
                }

                // Check 2: FaceAPI æµäººè‡‰
                const detection = await faceapi.detectSingleFace(img, new faceapi.TinyFaceDetectorOptions()).withFaceLandmarks();
                
                if (!detection) {
                    showBubble(bubble, "ğŸ¤” æµå””åˆ°äººæ¨£å–ï¼Ÿä½ ä¿‚å’ªéš±å½¢ä¿ ï¼Ÿ", true, true);
                    return;
                }

                const landmarks = detection.landmarks;
                const leftEye = landmarks.getLeftEye();
                const rightEye = landmarks.getRightEye();
                const eyeDist = Math.abs(leftEye[0].x - rightEye[3].x);
                const faceWidth = detection.detection.box.width;
                const brightness = getBrightness(img);

                if (brightness < 50) {
                    showBubble(bubble, "ğŸ’¡ é–‹ç›ç‡ˆå¯ä»¥å—ï¼Ÿä½ å—°é‚Šé›»è²»å¥½è²´ï¼Ÿ", true, false);
                } 
                else if (eyeDist < faceWidth * 0.25) {
                    showBubble(bubble, "ğŸ‘€ å´é¢ä¿‚éšï¼Œä½†æ­£é¢ä»²éšï¼Œä¿¾å€‹æ­£é¢é»ç‡å“å•¦ï¼", true, false);
                } 
                else if (detection.detection.score < 0.7) {
                    showBubble(bubble, "ğŸ˜ æˆ´ä½é»‘è¶…å¤ªæœ‰å‹å–‡ï¼æ‰£ä½ 50åˆ†ï¼", true, false);
                }
                else if (detection.detection.box.width < img.width * 0.15) {
                    showBubble(bubble, "ğŸ” æœ‰å‹ä½ è¡Œè¿‘å°‘å°‘å•Šï½", true, false);
                }
                else {
                    showBubble(bubble, "âœ… é€™å¼µç›¸å¥½æ­£ï¼", false, false);
                }
                
                checkReady();
            }, 500);
        }

        async function checkDog(event) {
            await loadFile(event, 'img2', 'box2', 'bubble2');
            const img = document.getElementById('img2');
            const bubble = document.getElementById('bubble2');
            dogStatus.isHard = false;
            bubble.style.display = 'none';
            btn.disabled = true;

            setTimeout(async () => {
                const predictions = await mobilenetModel.classify(img, 5); 
                let isDog = false;
                let detectedBreed = "";

                for (let p of predictions) {
                    const className = p.className.toLowerCase();
                    if (DOG_KEYWORDS.some(k => className.includes(k))) {
                        isDog = true;
                        detectedBreed = p.className.split(',')[0];
                        break;
                    }
                }

                if (!isDog) {
                    showBubble(bubble, "ğŸ¶ å””å¤ªä¼¼ç‹—å–... ä¸éæˆ‘åœ°ç…§è©¦ä¸‹å•¦ï¼", true, false);
                    dogStatus.isHard = true;
                    checkReady();
                } else {
                    showBubble(bubble, `âœ… æ”¶åˆ°ï¼ä¿‚ä¸€éš»å¯æ„›çš„ ${detectedBreed}`, false, false);
                    checkReady();
                }
            }, 500);
        }

        function showBubble(el, msg, isWarning, isError) {
            el.innerText = msg;
            el.style.display = 'block';
            
            if (isError) {
                el.style.border = '2px solid #d32f2f';
                el.style.color = '#d32f2f';
            } else if (isWarning) {
                el.style.border = '2px solid #fbc02d';
                el.style.color = '#f57f17';
                if (el.id === 'bubble1') humanStatus.isHard = true;
                if (el.id === 'bubble2') dogStatus.isHard = true;
            } else {
                el.style.border = '2px solid #2e7d32';
                el.style.color = '#2e7d32';
            }
        }

        function loadFile(event, imgId, boxId, bubbleId) {
            return new Promise(resolve => {
                const output = document.getElementById(imgId);
                const container = document.querySelector(`#${boxId} .img-container`);
                const plusSign = container.querySelector('span');
                
                if (event.target.files && event.target.files[0]) {
                    output.src = URL.createObjectURL(event.target.files[0]);
                    output.onload = () => { URL.revokeObjectURL(output.src); resolve(); }
                    plusSign.style.display = 'none';
                    output.style.display = 'block';
                }
            });
        }

        function checkReady() {
            // æª¢æŸ¥ Bubble ä¿‚å’ªç´…è‰² Error
            const bubble1 = document.getElementById('bubble1');
            const bubble2 = document.getElementById('bubble2');
            const isErr1 = bubble1.style.borderColor === 'rgb(211, 47, 47)'; // red color check
            
            // ç¢ºä¿å…©å¼µåœ–éƒ½æœ‰ï¼Œè€Œä¸”ç„¡ Error
            const img1Vis = document.getElementById('img1').style.display === 'block';
            const img2Vis = document.getElementById('img2').style.display === 'block';
            
            if (img1Vis && img2Vis && !isErr1) btn.disabled = false;
        }
        
        function getBrightness(image) {
            let canvas = document.createElement('canvas');
            canvas.width = image.width; canvas.height = image.height;
            let ctx = canvas.getContext('2d');
            ctx.drawImage(image, 0, 0);
            let imageData = ctx.getImageData(0,0,canvas.width,canvas.height);
            let r,g,b,avg;
            let colorSum = 0;
            for(let x = 0, len = imageData.data.length; x < len; x+=4) {
                r = imageData.data[x]; g = imageData.data[x+1]; b = imageData.data[x+2];
                avg = Math.floor((r+g+b)/3);
                colorSum += avg;
            }
            return Math.floor(colorSum / (image.width*image.height));
        }

        async function analyzeSimilarity() {
            const img1 = document.getElementById('img1');
            const img2 = document.getElementById('img2');
            btn.setAttribute("aria-busy", "true");

            setTimeout(async () => {
                const activation1 = mobilenetModel.infer(img1, true);
                const activation2 = mobilenetModel.infer(img2, true);
                const rawDist = cosineSimilarity(activation1, activation2);
                
                let score = mapRange(rawDist, 0.35, 0.75, 100, 10);
                
                let bonusTags = [];
                if (humanStatus.isHard && dogStatus.isHard) {
                    score += 5; bonusTags.push("ğŸ˜ å…©å€‹éƒ½å’å‹");
                } else if (humanStatus.isHard || dogStatus.isHard) {
                    score *= 0.9; bonusTags.push("ğŸ“‰ å—å…‰ç·š/è§’åº¦å½±éŸ¿");
                }

                const c1 = colorThief.getColor(img1);
                const c2 = colorThief.getColor(img2);
                const colorDist = Math.sqrt(Math.pow(c1[0]-c2[0],2) + Math.pow(c1[1]-c2[1],2) + Math.pow(c1[2]-c2[2],2));
                if (colorDist < 60) { score += 5; bonusTags.push("ğŸ¨ è‰²ç³»å¥½è¥¯"); }

                score = Math.min(99, Math.max(10, Math.round(score)));
                showResult(score, bonusTags);
                
                btn.setAttribute("aria-busy", "false");
            }, 100);
        }

        function showResult(score, tags) {
            document.getElementById('result-area').style.display = 'block';
            document.getElementById('score').innerText = score;
            const comment = document.getElementById('comment');
            if(score > 90) comment.innerText = "ğŸ˜± å¤±æ•£å¤šå¹´æ—¢è¦ªäººï¼";
            else if(score > 75) comment.innerText = "â¤ï¸ é»˜å¥‘åè¶³ï¼Œå¤©ç”Ÿä¸€å°ï¼";
            else if(score > 60) comment.innerText = "ğŸ˜ å¹¾æœ‰çˆ¶å­/æ¯å¥³ç›¸ï¼";
            else comment.innerText = "ğŸ˜‚ é›–ç„¶å””ä¼¼ï¼Œä½†å‹åœ¨æœ‰æ„›ï¼";

            const tagContainer = document.getElementById('tags');
            tagContainer.innerHTML = "";
            tags.forEach(t => tagContainer.innerHTML += `<span class="tag highlight">${t}</span>`);
        }

        function cosineSimilarity(t1, t2) {
            const v1 = t1.dataSync(); const v2 = t2.dataSync();
            let dotProduct = 0, normA = 0, normB = 0;
            for (let i = 0; i < v1.length; i++) {
                dotProduct += v1[i] * v2[i];
                normA += v1[i] * v1[i];
                normB += v2[i] * v2[i];
            }
            return dotProduct / (Math.sqrt(normA) * Math.sqrt(normB));
        }
        function mapRange(value, low1, high1, low2, high2) {
            return low2 + (high2 - low2) * (value - low1) / (high1 - low1);
        }
    </script>
</body>
</html>
